% processImage - determines centroid of the target object. 

% Worth noting that the return format is 
% centroid xCoord in idx(1), then yCoord in idx(2), which follows column,
% row formatting, instead of row, col.

% if requested object isn't valid empty string is returned

% all the other functions don't really need to be interacted with

function centroid = processImage(kinectImage, colourArg, shapeArg)    
    [colourMask,~] = createMaskHSV(kinectImage,colourArg);
    colourAndShapeMask = createShapeMask(colourMask, shapeArg);
%     imshow(colourAndShapeMask);

    centroid = findObjectCentroidsFromMask(colourAndShapeMask);
    centroid(1) = round(centroid(1));
    centroid(2) = round(centroid(2));

    if ~strcmp(centroid,'')
%         showObjectAndCentroid(kinectImage,centroid);
        centroid(1) = round(centroid(1));
        centroid(2) = round(centroid(2));
    end
%     showObjectAndCentroid(kinectImage, centroid)
end

function centroid = findObjectCentroidsFromMask(colourAndShapeMask)
    s = regionprops(colourAndShapeMask,'centroid');
    centroidArray = cat(1,s.Centroid);
    
    if isempty(centroidArray)
        centroid = '';
        return
    end
    
    centroid = centroidArray(1,:);
%     centroid = s.Centroid;
end

function shapeMask= createShapeMask(binaryMask, shape)
    if strcmp(shape, 'rect')
        areaThreshLo = 2000;
        areaThreshHi = 5000;
        eccentThreshLo = 0.5; 
        eccentThreshHi = 1;
        
    elseif strcmp(shape, 'circ')
        areaThreshLo = 100;
        areaThreshHi = 800;
        eccentThreshLo = 0.05; 
        eccentThreshHi = 0.2; 
    else
        shapeMask = binaryMask;
        return;
    end
    
    areaFilteredMask = bwareafilt(binaryMask, [areaThreshLo, areaThreshHi]);
    
    eccentAndAreaMask = bwpropfilt(areaFilteredMask, 'Eccentricity', [eccentThreshLo, eccentThreshHi]);

    %imfind circles if need be???

    shapeMask = eccentAndAreaMask;
end

function showObjectAndCentroid(image, centroid)
    imshow(image);
    hold on;
    plot(centroid(1), centroid(2), 'g*')
    hold off;
end

function [BW,maskedRGBImage] = createMaskHSV(RGB,colourArg)
% Auto-generated by colorThresholder app on 05-Aug-2020

% Convert RGB image to chosen color space
I = rgb2hsv(RGB);
if strcmp(colourArg, 'red')
    int1Min = 0;
    int1Max = 0.1;
    int2Min = 0.9;
    int2Max = 1.0;
    colourLogical = (I(:,:,1) >= int1Min & I(:,:,1) <= int1Max) | ...
        (I(:,:,1) >= int2Min & I(:,:,1) <= int2Max);

elseif strcmp(colourArg, 'blue')
    channel1Min = 0.610;
    channel1Max = 0.696;
    colourLogical = (I(:,:,1) >= channel1Min) & (I(:,:,1) <= channel1Max);
    
elseif strcmp(colourArg, 'yellow')
    channel1Min = 0.120;
    channel1Max = 0.220;
    colourLogical = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max);
    
else
    channel1Min = 0;
    channel1Max = 1;
    colourLogical = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max);
end

% Saturation Thresholds
channel2Min = 0.779;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.886;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = colourLogical & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end

